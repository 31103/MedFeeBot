# **診療報酬改定通知監視Bot 仕様書**

## **1\. 概要**

本ドキュメントは、厚生労働省のウェブサイトにおける診療報酬に関連するページを定期的に監視し、新たな通知文書（PDFファイル）が掲載された場合に、指定されたSlackチャンネルへ通知を行うボット（以下、本ボット）の仕様を定義するものである。本ボットはGoogle
Cloud Functions上でPythonを用いて実装される。**プロジェクト名は MedFeeBot
とする。**

## **2\. 背景**

診療報酬改定や関連通知は、医療機関や関連事業者にとって極めて重要な情報である。厚生労働省のウェブサイトで公開されるこれらの情報は、迅速に把握し対応する必要がある。しかし、担当者が定期的にウェブサイトを確認する作業は負担が大きく、見落としのリスクもある。本ボットは、この監視・通知プロセスを自動化し、情報収集の効率化と迅速化を図ることを目的とする。

## **3\. 機能要件**

本ボットが満たすべき機能要件を以下に示す。

### **3.1. ウェブページ監視**

- **監視対象:** 指定された厚生労働省のウェブページを監視する。
  - 初期監視対象URL:
    https://www.mhlw.go.jp/stf/seisakunitsuite/bunya/0000188411\_00045.html
  - 監視対象URLは環境変数で設定可能であること。
- **監視頻度:** 定期的に監視対象ページの内容を取得する。
  - 監視頻度はCloud Schedulerで設定可能であること（例:
    1時間ごと、1日1回など）。デフォルトは1時間ごととする。
- **取得方法:** HTTPリクエストにより、監視対象ページのHTMLコンテンツを取得する。

### **3.2. 新規PDF検知**

- **PDF特定:**
  取得したHTMLコンテンツを解析し、ページ内に存在するPDFファイルへのリンク（\<a\>タグのhref属性が.pdfで終わるもの、またはクエリパラメータが付与されたPDFリンク（例:
  file.pdf?version=1）も含む）をすべて特定する。相対パスの場合は、基底URL（監視対象ページのURL）と結合して絶対URLに変換する。検知の際には正規表現を使用し、「.pdf」またはクエリパラメータが付いた「.pdf?」パターンの両方を捕捉する。
- **新規判定:**
  - ボットは、過去に検知したPDFファイルの絶対URLリストを永続化ストレージ（Google
    Cloud Storage）に保持する。
  - 今回取得したPDFリンクの絶対URLリストと、永続化されたURLリストを比較する。
  - 永続化リストに存在しないURLを「新規PDF」として判定する。
  - 新規PDFと判定された場合、そのURLを永続化リストに追加保存する。
- **初回実行:**
  **ボットの初回実行時は、ページ内に存在するすべてのPDFリンクを検知し、通知は行わず、それらをすべて既知のURLとして永続化リストに保存する。**

### **3.3. Slack通知**

- **通知トリガー:** 新規PDFが検知された場合にのみ通知処理を実行する。
- **通知先:** 指定されたSlackのチャンネル（環境変数 TARGET\_SLACK\_CHANNEL\_ID
  で指定）に通知メッセージを投稿する。
- **通知メッセージ形式:** 通知メッセージには、最低限以下の情報を含むこと。
  - 新規PDFが検知された旨を示すテキスト（例:
    「【診療報酬関連】新規通知（PDF）が掲載されました」）
  - 新規PDFのタイトル（リンクテキストから取得）
  - 新規PDFへの直接リンクURL（絶対URL）
  - （任意）掲載ページへのリンクURL
  - （任意）検知日時

【例】\
\----------------------------------------\
【診療報酬関連】新規通知（PDF）が掲載されました :bell:

掲載ページ:
https://www.mhlw.go.jp/stf/seisakunitsuite/bunya/0000188411\_00045.html

ファイル名: 〇〇に関する通知（令和〇年〇月〇日）\
URL: https://www.mhlw.go.jp/path/to/new\_document.pdf

検知日時: 2025/04/13 14:00:00\
\----------------------------------------

## **4\. 非機能要件**

本ボットが満たすべき非機能要件を以下に示す。

- **信頼性:**
  - **エラーハンドリング:** ネットワークエラー、HTTPエラー（4xx,
    5xx）、ウェブページの構造変更、HTML解析エラーなど、予期せぬエラーが発生した場合でも、関数実行が異常終了しないように適切に例外処理（try-except）を行う。
  - **エラーログ:** エラー発生時には、Google Cloud
    Loggingに詳細なエラー情報（スタックトレース含む）を記録する。
  - **エラー通知:** **エラー発生時には、Google Cloud
    Loggingへの記録に加え、原則として管理者向けSlackチャンネル（環境変数
    ADMIN\_SLACK\_CHANNEL\_ID で指定）にもエラー内容を通知する。ただし、Slack
    APIへの通知自体に失敗した場合は、Loggingへの記録のみとする。**
  - **GCSアクセスエラー:** **Google Cloud Storage (GCS)
    へのアクセスエラー発生時の挙動は以下の通りとする。**
    - **既知URLリストの**読み込み**に失敗した場合:**
      詳細なエラーをLoggingに記録し、管理者向けSlackチャンネルに通知後、関数実行を**異常終了**させる（新規かどうかの判定が不可能なため）。
    - **既知URLリストの**書き込み**に失敗した場合:**
      詳細なエラーをLoggingに記録し、管理者向けSlackチャンネルに通知する。関数実行は継続するが、次回実行時に同じPDFが再度通知される可能性があることを許容する。（書き込みリトライの実装も検討する）
  - **リトライ:**
    一時的なネットワークエラーの可能性がある場合は、限定的なリトライ処理を実装することを検討する（GCFの再試行機能も考慮）。
- **保守性:**
  - **開発言語:**
    **Pythonを採用し、コードの可読性と保守性を高めるために型アノテーションを積極的に使用する
    (typingモジュール活用)。**
  - **コメント:** 関数、主要なロジックブロックには説明的なコメントを付与する。
  - **設定値管理:** **設定値の管理方針は以下の通りとする。**
    - **Secret Manager:** Slackボットトークン等の機密情報を格納する。
    - **環境変数:** 監視対象URL、通知先SlackチャンネルID
      (TARGET\_SLACK\_CHANNEL\_ID)、管理者向けSlackチャンネルID
      (ADMIN\_SLACK\_CHANNEL\_ID)、GCSバケット名/ファイルパス、その他動作制御フラグ等の非機密情報を設定する。GCFの機能を利用し、Secret
      Managerに格納した機密情報を環境変数として安全に参照することも可能。
- **セキュリティ:**
  - **機密情報管理:** **Slack APIトークン等の機密情報は、Google Cloud Secret
    Managerを利用して安全に管理し、** Cloud
    Functions実行時に環境変数経由で安全に読み込む。
  - **通信:** 外部へのHTTPリクエスト（MHLWサイト、Slack API）はHTTPSを使用する。
  - **依存関係:**
    依存ライブラリは定期的に脆弱性情報を確認し、必要に応じて更新する。

## **5\. システム構成**

- **実行環境:** **Google Cloud Functions (第2世代) を利用する。**
  - **トリガー:** Cloud Schedulerによって定期実行トリガーを設定する（例:
    毎時0分）。
- **開発言語:** **Python (3.9以降を推奨)**
- **主な使用ライブラリ (Python):**
  - requests: HTTP通信用
  - beautifulsoup4 (または lxml): HTML解析用
  - slack\_sdk: Slack API連携用
  - google-cloud-storage: Google Cloud Storage連携用
  - python-dotenv: (ローカル開発用) 環境変数読み込み
  - typing: 型アノテーション用 (標準ライブラリ)
- **既知PDFリストの永続化:**
  - **Google Cloud Storage (GCS) 上のファイル（例: JSON形式）に既知のPDF
    URLリストを保存・読み込みする。**
  - GCSバケット名、ファイルパスは環境変数で指定する。
  - GCF実行サービスアカウントには、対象GCSオブジェクトへの読み書き権限を付与する。
- **構成概要図:**\
  graph LR\
  subgraph Google Cloud\
  Scheduler\[Cloud Scheduler\] \-- triggers \--\> GCF\[Cloud Functions
  (Python)\];\
  GCF \-- reads/writes \--\> GCS\[Cloud Storage Bucket/File\];\
  GCF \-- reads secret \--\> SecretManager\[Secret Manager\];\
  GCF \-- sends logs \--\> Logging\[Cloud Logging\];\
  GCF \-- sends metrics \--\> Monitoring\[Cloud Monitoring\];\
  end\
  GCF \-- fetches HTML \--\> MHLW\[MHLW Website\];\
  GCF \-- sends notification \--\> Slack;\
  GCF \-- sends error alert \--\> SlackAdmin\[Slack Admin Channel\];

## **6\. 運用保守**

- **ログ:** **Google Cloud Logging を利用して、**
  関数の実行開始/終了、検知した新規PDFのURL、発生したエラー情報などを記録する。ログレベル（INFO,
  ERRORなど）を適切に使い分ける。
- **監視:** **Google Cloud Monitoring を利用して、**
  関数の実行回数、成功/失敗数、実行時間、エラーログなどを監視する。必要に応じてアラートを設定する。
- **設定変更:** 監視対象URL、SlackチャンネルID、GCS設定等の変更は、Cloud
  Functionsの環境変数またはSecret
  Managerの値を更新し、関数を再デプロイすることで反映する。
- **デプロイ:** Cloud Source Repositories, GitHub, GitLab等とCloud
  Buildを連携させ、ソースコードの変更をトリガーに自動デプロイするCI/CDパイプラインの構築を推奨。
- **バージョン管理と開発プロセス:**
  - **リポジトリ:** GitHub上でソースコードを管理する。リポジトリ名は MedFeeBot
    とする。
  - **バージョニング戦略:** **セマンティックバージョニング (SemVer)**
    を採用する。
    - メジャーバージョン (X.0.0): 後方互換性のない変更
    - マイナーバージョン (0.X.0): 後方互換性のある機能追加
    - パッチバージョン (0.0.X): バグ修正
    - リリースタグはバージョン番号を「v」に続けて記述する (例: v1.0.0)
    - リリース時に変更履歴(CHANGELOG.md)を更新する
  - **ブランチ戦略:** **GitHub Flow** を採用する。
    - main ブランチは常にデプロイ可能な安定版とする。
    - 機能追加やバグ修正は、main ブランチから作成したフィーチャーブランチ (例:
      feat/add-new-feature, fix/resolve-bug) で行う。
    - 開発が完了したフィーチャーブランチは、プルリクエストを作成し、コードレビューを経て
      main ブランチにマージする。
    - main ブランチへのマージをトリガーとして、Cloud
      Build等でGCFへのデプロイが自動的に行われるように設定することを推奨する。
  - **コミットメッセージ:** **Conventional Commits** の規約に従う。
    - コミットタイプ (例: feat, fix, docs, style, refactor, test, chore)
      を接頭辞として付与する。
    - 例:
      - feat: 新規PDF検知ロジックを追加
      - fix: 相対URLの絶対URL変換処理の不具合を修正
      - docs: README.mdにセットアップ手順を追記
      - chore: 依存ライブラリのバージョンを更新

## **6.5. テスト戦略**

本ボットの品質を担保するため、以下のテスト戦略を採用する。

### **6.5.1. テストレベル**

- **単体テスト (Unit Test):**
  - 個々の関数・メソッドの機能を検証する。
  - Pytestフレームワークを使用して実装する。
  - 全ての公開関数は少なくとも1つのテストケースをカバーする。
  - 型アノテーションの整合性検証にはmypyを使用する。

- **結合テスト (Integration Test):**
  - コンポーネント間の連携を検証する。
  - 主要なシナリオ（PDF検知→GCS保存→Slack通知）の一連の流れをテストする。
  - 外部依存（厚生労働省サイト、GCS、Slack
    API）はモックに置き換え、実際の外部サービスとの連携なしで機能検証を行う。

### **6.5.2. テスト自動化**

- **CI/CD連携:**
  - GitHub ActionsまたはCloud Buildと連携し、Pull
    Request作成時とmainブランチへのマージ時に自動テストを実行する。
  - 単体テストと結合テストは全PRで実行し、E2Eテストはmainブランチへのマージ時のみ実行する。

- **コードカバレッジ:**
  - 単体テストのコードカバレッジは80%以上を目標とする。
  - カバレッジレポートはPR時に自動生成し、レビュー時の参考資料とする。

### **6.5.3. テストデータ管理**

- **テストフィクスチャ:**
  - 実際のHTML構造を模したサンプルHTMLファイルを用意する。
  - 様々なパターンのPDFリンク（相対パス、絶対パス、クエリパラメータ付きなど）を含めたテストケースを準備する。

- **環境分離:**
  - 開発環境、テスト環境、本番環境を明確に分離する。
  - 環境ごとに異なる設定値（GCSバケット名、Slackチャンネル等）を.env.dev,
    .env.testなどで管理する。

### **6.5.4. 特殊ケーステスト**

- **障害テスト:**
  - ネットワーク遅延、タイムアウト、GCSアクセス失敗などの異常系テストを実施する。
  - 様々なHTTPエラーコード（404, 500など）への対応をテストする。

- **長時間テスト:**
  - 実環境を模した状態で24時間以上の継続運用テストを実施し、メモリリークなどの問題がないことを確認する。

## **7\. 今後の拡張性（任意）**

- 複数の監視対象URLに対応する（設定ファイルやデータベースで管理）。
- PDFファイル名やリンクテキストに含まれるキーワードでフィルタリングし、特定の通知のみをSlack通知する機能。
- Slack以外の通知チャネル（メール、Microsoft Teams等）への対応。
- 検知履歴を管理・表示する簡易なWebインターフェースの構築（例: Cloud Run \+
  Flask/Django）。
